# 항해 Lite 백엔드 코스 - e-커머스 서비스




- `e-커머스 상품 주문 서비스` 입니다.

## 🎯 프로젝트 개요

## Docs
- [API 명세서](./docs/api_spec.md)
- [ERD](./docs/erd.md)
- [인프라 구조도](./docs/infra_structure.md)


---
### 핵심 기능
- ✅ 회원 관리 (가입/로그인/포인트)
- ✅ 상품 조회 및 재고 관리
- ✅ 주문/결제 처리 (트랜잭션 보장)


---
### 아키텍처 개요
<img src="./docs/image/인프라구조도.png">

---
### 요청 처리 흐름
1. 사용자 요청
2. WAS로 접근
3. 비즈니스 로직 처리(RDB 및 Redis 조회)
4. 응답 반환


## 아키텍처 결정 기록 (ADR)

---
### ADR-001 : e-commerce 애플리케이션 개발 언어 및 프레임워크 선택
**문제점**
- e-commerce 애플리케이션 개발에 필요한 언어와 프레임워크 선택 필요

**결정**
- java/spring 선택

**근거**
- 개발자(나)의 언어와 프레임워크에 대한 이해도가 java와 spring 에 대한 이해도가 보다 높기 때문에 해당 언어와 프레임워크를 선택.
- 안정적인 생태계와 커뮤니티 지원
- 대규모 애플리케이션 확장성 우수

📄 [상세 내용](docs/infra_structure.md#adr-001--e-commerce-애플리케이션-개발-언어-및-프레임워크-선택)

---
### ADR-002 : MySQL 도입
**문제점**
- 애플리케이션의 데이터를 저장할 RDB 선택 필요

**결정**
- MySQL 선택

**근거**
- 안정적인 생태계와 커뮤니티 지원
- 개발자(나)가 RDB 중 MySQL에 가장 친숙함.

**대안**
- MariaDB
- Oracle
- PostgreSQL

📄 [상세 내용](docs/infra_structure.md#adr-002--mysql-도입)

---
### ADR-003 : Docker 도입
**문제점**
- 로컬 개발 환경과 프로덕션 환경의 불일치로 인한 배포 복잡도 증가

**근거**
- 개발/프로덕션 환경 통일
- 빌드와 배포 자동화 가능
- 향후 Kubernetes 확장성 고려

**대안**
- 도커를 사용하지 않고, 온프레미스에서 직접 서버를 띄울 수도 있다.
- 하지만, 추후 클라우드로 도입 혹은 Kubernetes의 확장성을 고려하여, 도커를 적극적으로 도입함.

📄 [상세 내용](docs/infra_structure.md#adr-003--docker-도입)

---

### 각 챕터마다 배운 것

<details>
<summary> <b> Step 1. TDD 기본다지기</b> </summary>

### 기술적 성장

- 새로 학습한 개념
  - 행위 검증에서 then.should 절이 쓰인다는 것 
  - 호출 여부가 중요할 때 사용한다는 것 
  - Mocking을 했을 때 메서드 내부에서 호출하는 메서드를 Stub 해줘야하는 것 
  - given절에서는 matcher(eq, anyXX)를 사용하지만, willReturn에서는 matcher가 아닌 실제 값을 넣어줘야하는 것 
- 기존 지식의 재발견/심화 
- @ExtendWith(MockitoExtension.class) 와 @WebMvcTest 차이 그리고 @mock과 @MockBean의 차이 를 알 수 있었고,
  - @WebMvcTest 와 @MockBean을 사용하는 것보다 @ExtendWith(MockitoExtension.class) 와 @mock을 사용하는 것이 더욱 빠르다는 것.
- 행위 검증/상태 검증이 있는 것 -> 기존에 자주 쓰던 assert는 상태 검증을 하는 것

- 규칙 정리 
  - 하나에 한 책임 
  - 외부 의존성 처리 
  - 테스트는 재현 가능해야함(랜덤/시간 의존 제거 -> 고정된 수치)
  - 명확한 테스트 이름 
  - `Assertions`은 명확하게 
    - 보다 크다 X
    - "="
  
- 안티패턴
  - 테스트 간 상태 공유 X
  - sleep 사용 X
    - 비동기 처리 대기 시 Awaitillity 라이브러리 등 사용 X
  - 의미 없는 이름X
  - 과도한 Mock 검증
    - 내부 구현을 너무 상세히 검증하기 보단 외부로 보이는 결과에 집중하도록

- 알게된 내용들
  - 상태검증(Assert)/행위검증(then/should)
    - GPT가 둘 다 해야된다고 알려주긴했지만, 둘 다 작성할 때도 있고, 상태가 중요하다면 상태를, 호출 여부가 중요하면 행위 검증을
  - BDDMockito
    - 검증 절에서 verify 대신 then 쓰면 더 가독성이 좋다
  - then.should 체이닝 가독성이 좋다.
  - then하고 should() 함수에 인자를 안주면 1회 호출을 검증
    - 호출을 안했다는 것을 검증하려면 should(never())
    - 만약 여러 번 호출 검증은 should(times(n))
  - 비동기 호출이나 이벤트 검증은 이벤트 관련 테스트도 가능
    - 대부분 호출 여부만 보면 된다
  - 만약 통합으로 보면 DB 접근과 같은 외부 사용시 Mocking 하거나 스텁을 사용하면 된다.
  - ArgumentCaptor를 쓰지말고, anyXX 를 활용하자
  - eq() 를 사용해서 특정 값을 좁혀놓는것도 안정성에 좋다
  - 테스트 코드 작성시 굳이 하지 않아도 될 테스트는 하지 않아도 된다.
    - 예를 들어, RequestParam 에서 Long으로 받기로 되어있는데, 문자열로 들어올 때 스프링이 걸러주는지를 테스트 하는 경우
      - 스프링이 알아서 걸러주기 때문에 굳이 하지 않아도 되는 테스트 케이스이다.
  - given , when , then 에도 명확하게 주석 달기
  - 하나의 케이스에서 여러 검증을 수행하는 경우 @nested를 활용할 수 있다.

- 추후 해볼 것!
  - given // when // then 명확히 주석으로 나누기
  - 서비스 레이어 명확히 주석으로 나누기
  - then should
  - 동시성 고려하기
</details>


<details>
<summary> <b>Step 2. 서버 구조 설계</b> </summary>

- 깨닫게 된 것
  - 문서가 중요
  - 설계는 곧 문서로 나타남

- 배운 것
  - 문서대로 개발 진행
  - 설계가 잘 되어있으면 개발은 스무스함.

**중요**
- 필요한 모든 내용이 들어가 있는가
  - 필요한 내용은 모두 들어가 있어야 한다.
    - 실제 설계한 문서와 설계도를 가지고 개발을 하려면 개발 과정에서 어떤 기술을 사용하고, 어떤 스펙으로 이 서버가 구성되는지 제대로 들어가있어야 함.
- 필요한 내용만 들어가 있는가
  - 지금 생각하고 있는 서비스가 있는데 범위를 넘어서 지금은 아니지만, 나중엔 필요할 거 같은 판단되는 기능 "정말 확실하게 필요한 케이스는 모르겠지만, 잘은 모르지만, 뭔가 있어야될 거 같은.. 명확하지 않은 것"을 설계에 포함하면, 실제로 설계를 했더라도 개발 과정에서 어려움을 느낄 수 있다.
  - 설계가 깔끔하게 되어있으면 개발은 스무스하게 넘어간다. 설계 문서를 그대로 따라가기 때문이다. 그러나 필요한 내용만 들어가있지 않으면 이런 내용이 점점 모호해진다. 그렇기 때문에 내가 이해한 필요한 내용만 있어야 한다.
- 모든 구성 요소를 이해하고 있는가
  - 예를 들어, 인프라 구성도에서 "대용량 처리 시스템에는 카프카가 있어야하는데, 나는 카프카를 모르지만 어쨌든 넣는다" 이런 것은 지양해야한다. 왜냐하면 실제로 당장 써먹을 수 없는 설계도이기 때문이다.
- 협업을 고려한 문서인가
  - 내가 설계한 문서가 적합한지, 개선할 것은 없는지, "우리 시스템이 이렇게 구현될것이다" 라는 의미로도 쓰일 문서이다.
  - 다른 사람이 읽기 불편하지 않아야 하는 그런 문서가 되지 않아야하고, 나만 아는 단어가 되면 안 된다.


#### 멘토님이 생각하는 설계 FLOW**

   1. 무조건 있을 수 밖에 없는 기능을 생각한다. -> 예를 들어, e-commerce라면 상품 조회 / 구매 / 포인트 충전 등등 
   2. API 명세
   3. ERD
   4. 인프라 구조도
   5. 서비스에서 특별히 붙여야되는 기능을 정리한다.
      -> 여기에 맞춰서 2, 3, 4 를 지속적으로 업데이트한다.


- 코치님은 개인적으로 DB가 데이터를 정하는 것을 선호하지 않음.(예를 들면 auto increment가 될 수 있음)
  - 애플리케이션 내의 비즈니스로직으로 컨트롤하는 것을 선호함. 
  - 일단 나도 코치님 따라 해보는 것으로 하기
- 모든 선택의 근거가 있어야함(찾는 것 아님)
- ERD가 API 명세는 충족하지만 API 명세가 ERD를 충족하지 못할 수도 있다.
  - 예를 들어 유저의 성별이 M | F 로 enum 처리를 할 수도 있지만 이후 사회적 이슈에 따라 유저를 표기하지 않을 수도 있고 없는 경우도 있다.
  - 따라서 API 명세로는 그렇게 되어있지만 ERD 상으론 열려있는 구조가 되어야 한다
- 문서는 시간이 지나서 계속 바뀔 수 밖에 없다. 
  - 처음부터 완벽할 수 없다.
- 인프라 구조도에서 app의 ip로 접속하기보단 앞에 DNS를 통해서 프론트 개발자가 쉽게 접근할 수 있도록 한다. 
- 개발 언어와 스택, DB 같은 경우에도 선택의 이유가 있어야한다.
  - 우리 팀이 해당 언어 및 프레임워크에 대한 이해가 높다)
- ERD에서 애매모호할 땐 일단은 STRING으로 지정한다.
  - STRING에서 INTEGER로 변환하는 것은 쉽지만 반대의 경우 INTEGER로 했다가 해당 값에 문자열이 들어가면 그렇게 변환하는 것은 쉽지 않다


- 개선할 것
  - API 명세 : 조금 더 디테일하게 (일단은 ai 피드백 필요)
  - 인프라 구조도 : 지금 redis가 필요 없음
  - 도메인 
    - 회원
      - 역할 : 구매자 / 판매자 : 기본 구매자, 회원의 의사에 따라 판매자도 가능

</details>

<details>
<summary> <b>Step 3. 클린 아키텍처로 안정성 확보</b> </summary>

### 클린 아키텍처 특징
  - 의존성 방향이 외부에서 내부로 간다.
  - 애플리케이션 내부에서는 외부에 어떤 일이 발생했는지 알 수 없다.
  - 도메인 객체가 프레임워크에 종속되지 않고, 독립적이다.
  - 프레임워크에 종속적이지 않아 테스트가 용이하다.
- 단점
  - JPA의 좋은 기능인 변경감지를 잘 활용하지 못한다.
  
근데, 현재 아직은 잘 모르겠다..
좀 더 사용해봐야할 듯

### 해당 STEP에서 한 것

#### 1. Controller에서 요청 값에 대해 검증할 때, ArgumentProvider를 도입

- 기존의 MockMvc를 통해서 요청에 대한 값을 검증했었다.
- 그런데, 일일이 given에서 값을 세팅하고, when then 절에서 `mockMvc.perform` 을 계속 하다보니 귀찮았다.
- 테스트는 애플리케이션의 개발 속도를 증가시켜줘야 하는데, 필드가 하나씩 늘어날 때마다 계속해줘야했다.
- 이 때 ArgumentProvider를 도입함으로써 요청 값에 대한 검증 테스트가 훨씬 간결해졌다.

#### 2. 주문과 결제 로직 분리

- 기존에는 주문 로직에 결제와 관련된 모든 로직을 때려넣었다.
- 그런데, 주문에 대한 로직에 너무 많은 책임이 있었고, 결제 로직에서 해도 될 부분이 주문 로직에 포함이 되어있었다.
- 클린 아키텍처 구조로 변경하려고 했는데, 주문에 책임이 너무 많이 몰려있다보니, 분리하게 되었다.
- 주문 / 결제를 분리하고 보니 클린 아키텍처로 구조 변경하는 것이 매우 쉬워졌다.

#### 3. 주문 로직에 클린 아키텍처 도입

- 패키지 구조가 3개에서 4개로 늘어났다.
- controller, service, repository 구조에서 interfaces, application, domain, infrastructure 구조로 변경되었다.

- interfaces 에서 클라이언트로부터 요청을 받고, 요청은 application 으로 가게된다.
- application에서 domain으로 향하게 되고, domain에서는 domain 로직을 수행한 후, 다시 application으로 향하게 된다.
- application에서는 infrastructure 로 향하게 되고, infrastructure는 외부에서 해야할 일을 수행한 다음, interfaces 로 응답을 보내게 된다.



### 이후 해야될 것

1. 쿠폰 관련 기능 추가
2. 현재 하나의 주문에 하나의 상품과 수량만 받지만 여러 개를 받을 수 있도록 해야한다.
3. 현재 각 도메인의 Id는 Long 타입으로 받고 있다. 이를 UUID, 혹은 복잡한 Id를 사용하도록 해야한다.
4. 다른 도메인도 클린 아키텍처 구조로 변경해야 한다.
5. 회원과 관련된 기능 추가(JWT 도입, 가입, 로그인 등등)


### 의문점

#### 1. 서비스 계층에서 @Service를 빼야한다고 함.

- 서비스 계층에서 @Service를 빼야한다고 한다. 하지만, @Service를 빼면 @Bean으로 등록해야한다.
- 스프링에 종속되지 않게 하기 위해서 @Service를 빼는 건데, 결국은 애플리케이션을 사용할 때는 얘를 Bean으로 올려야 한다. 
- 그럼 결국 스프링에 종속되는 건데... 이게 맞나??

**클로드 코드한테 물어보고 얻은 답 정리**
- 어차피 스프링을 씀.
  - 따라서 **독립/종속적보다는 의존성 방향이 중요.**
- POJO로 하고, Bean으로 올린다고 해도, 결국 의존하는 객체도 결국 스프링 컨텍스트에 올라가야 함.
  - 테스트도 의존하는 객체를 Mock 처리해야 함.
- 그냥 @Service를 붙이자.

### 느껴야하는 것.

- SOLID를 느껴야 함.
  - 아직은 안 느껴짐.
  - 현재 나는 클린 아키텍처에 대한 이해도 아직 떨어짐..


## 라이브 세션

**라이브 세션 주제**
- 너무 많은 것을 담으려고 하지 말자
- 아키텍처라는 것의 의의를 이해하기
- '클린'하다는 것이 무엇인지 설명할 수 있는가?


**큰 주제**
- 너무 많은 것을 담으려고 하지말자.
- 아키텍처라는 것의 의의를 이해하기
- '클린'하다는 것이 무엇인지 설명할 수 있는가?

#### 아키텍처

- 아키텍처가 왜 나왔는지 알아야 한다.
  - Layered Architecture은 1980년대에 나옴(참고)
- 아키텍처는 약속이다.

#### 클린 아키텍처

- 클린 아키텍처는 처음에 도입했을 때 "잘 적용되어 있는 것이 맞는가?"라는 의문이 드는 것이 맞다.
  - 이후에 클린 아키텍처에 대한 철학과 배경을 이해하게 되면서 잘 적용되었는지 판단할 수 있다.

- **중요한 것**
  - UseCase 와 Entity가 가장 안쪽에 있는가(순수한가)
  - UseCase 와 외부세계가 완벽하게 분리되어 있는가?

#### 세션 이후 내가 해야할 것

- core 주문 로직만 클린 아키텍처로 적용하는 것이 요구사항이었고, 제대로 된 것이 맞는지 의아했다.
- 결론은 제대로 된 것이 아니다.
  - 주문은 잘 했어도, 주문 로직에서 회원 조회, 상품 조회는 여전히 외부 세계(DB)와 완벽하기 분리되어있지 않고, JPA를 애매하게 사용하고 있다.
  - 이후 해야할 것은 core 쪽을 clean 하게 유지보수 하는 것이다.

#### 클린 아키텍처로 구조 변경 하면서 느낀 점

- 테스트 코드가 좀더 도메인 중심의 코드로 변경되고 있다.
  - 되게 편하다.
  - 특히 Mocking 처리할 때, 일일이 Id를 `Utils.setId()` 같은 메서드를 사용해서 Id를 주입해야해줬지만, 지금은 그냥 `member.assignId(id)` 같은 도메인 모델의 메서드를 사용하고, 이를 `willReturn()` 절에 바로 넣을 수 있어서 되게 편하다. 
- 구조 변경 중인데, 당연한 말이지만, 그만큼 테스트 코드를 건드려야할 부분이 많다.
  - 특히 반복적으로 given절을 많이 손대는 게 좀 귀찮긴한데, 이후, 이 부분을 따로 private 메서드로 뽑아서 편리하게 사용하도록 해야겠다.
- 구조 변경하는 게 쉽지가 않다. 특히 테스트 코드까지 손봐야하는 경우, 오래 걸린다. 하지만, 계속 하게 되면, 빠르게 할 거 같지만,, 뛰엄뛰엄 하려하니 쉽진않다.


</details>

<details>
<summary> <b>Step 4. DB 구조로 데이터 정합성 확보</b> </summary>

### 해당 스텝에서 배운 것
- 데이터 모델링
- 락과 동시성 전략
- 인덱스 및 쿼리 설계
- 읽기 스케일아웃 및 복제 지연
- 파티셔닝과 샤딩
- CQRS와 Outbox

### 해당 스텝에서 한 것
- 모든 도메인을 클린 아키텍처 구조로 변경
- 각 도메인의 비즈니스 로직 테스트 작성
- Presentation 계층에서의 요청값 검증 방식 변경 
  - 일일이 given.when.then 에서 ArgumentProvider 를 사용하는 방식으로 변경
- 쿠폰 도메인 기능 구현
  - 쿠폰 생성
  - 쿠폰 조회
  - 쿠폰 발행
- 주문/결제 로직 분리
- 주문/결제 시 Outbox 패턴 적용

### 얻은 것
- 클린 아키텍처 구조에 익숙해짐
  - 하지만 여전히 잘 짜여진 구조인지는 의문임.
- 복잡한 비즈니스 로직 구현
  - 실무에서 코딩을 하지 않아 익숙지가 않은 거 같음..**빨리 이직해야함**




</details>