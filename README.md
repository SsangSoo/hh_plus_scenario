# 항해 Lite 백엔드 코스 - e-커머스 서비스




- `e-커머스 상품 주문 서비스` 입니다.

## 🎯 프로젝트 개요

## Docs
- [API 명세서](./docs/api_spec.md)
- [ERD](./docs/erd.md)
- [인프라 구조도](./docs/infra_structure.md)


---
### 핵심 기능
- ✅ 회원 관리 (가입/로그인/포인트)
- ✅ 상품 조회 및 재고 관리
- ✅ 주문/결제 처리 (트랜잭션 보장)


---
### 아키텍처 개요
<img src="./docs/image/인프라구조도.png">

---
### 요청 처리 흐름
1. 사용자 요청
2. WAS로 접근
3. 비즈니스 로직 처리(RDB 및 Redis 조회)
4. 응답 반환


## 아키텍처 결정 기록 (ADR)

---
### ADR-001 : e-commerce 애플리케이션 개발 언어 및 프레임워크 선택
**문제점**
- e-commerce 애플리케이션 개발에 필요한 언어와 프레임워크 선택 필요

**결정**
- java/spring 선택

**근거**
- 개발자(나)의 언어와 프레임워크에 대한 이해도가 java와 spring 에 대한 이해도가 보다 높기 때문에 해당 언어와 프레임워크를 선택.
- 안정적인 생태계와 커뮤니티 지원
- 대규모 애플리케이션 확장성 우수

📄 [상세 내용](docs/infra_structure.md#adr-001--e-commerce-애플리케이션-개발-언어-및-프레임워크-선택)

---
### ADR-002 : MySQL 도입
**문제점**
- 애플리케이션의 데이터를 저장할 RDB 선택 필요

**결정**
- MySQL 선택

**근거**
- 안정적인 생태계와 커뮤니티 지원
- 개발자(나)가 RDB 중 MySQL에 가장 친숙함.

**대안**
- MariaDB
- Oracle
- PostgreSQL

📄 [상세 내용](docs/infra_structure.md#adr-002--mysql-도입)

---
### ADR-003 : Docker 도입
**문제점**
- 로컬 개발 환경과 프로덕션 환경의 불일치로 인한 배포 복잡도 증가

**근거**
- 개발/프로덕션 환경 통일
- 빌드와 배포 자동화 가능
- 향후 Kubernetes 확장성 고려

**대안**
- 도커를 사용하지 않고, 온프레미스에서 직접 서버를 띄울 수도 있다.
- 하지만, 추후 클라우드로 도입 혹은 Kubernetes의 확장성을 고려하여, 도커를 적극적으로 도입함.

📄 [상세 내용](docs/infra_structure.md#adr-003--docker-도입)

---

### 각 챕터마다 배운 것

<details>
<summary> <b> Step 1. TDD 기본다지기</b> </summary>

### 기술적 성장

- 새로 학습한 개념
  - 행위 검증에서 then.should 절이 쓰인다는 것 
  - 호출 여부가 중요할 때 사용한다는 것 
  - Mocking을 했을 때 메서드 내부에서 호출하는 메서드를 Stub 해줘야하는 것 
  - given절에서는 matcher(eq, anyXX)를 사용하지만, willReturn에서는 matcher가 아닌 실제 값을 넣어줘야하는 것 
- 기존 지식의 재발견/심화 
- @ExtendWith(MockitoExtension.class) 와 @WebMvcTest 차이 그리고 @mock과 @MockBean의 차이 를 알 수 있었고,
  - @WebMvcTest 와 @MockBean을 사용하는 것보다 @ExtendWith(MockitoExtension.class) 와 @mock을 사용하는 것이 더욱 빠르다는 것.
- 행위 검증/상태 검증이 있는 것 -> 기존에 자주 쓰던 assert는 상태 검증을 하는 것

- 규칙 정리 
  - 하나에 한 책임 
  - 외부 의존성 처리 
  - 테스트는 재현 가능해야함(랜덤/시간 의존 제거 -> 고정된 수치)
  - 명확한 테스트 이름 
  - `Assertions`은 명확하게 
    - 보다 크다 X
    - "="
  
- 안티패턴
  - 테스트 간 상태 공유 X
  - sleep 사용 X
    - 비동기 처리 대기 시 Awaitillity 라이브러리 등 사용 X
  - 의미 없는 이름X
  - 과도한 Mock 검증
    - 내부 구현을 너무 상세히 검증하기 보단 외부로 보이는 결과에 집중하도록

- 알게된 내용들
  - 상태검증(Assert)/행위검증(then/should)
    - GPT가 둘 다 해야된다고 알려주긴했지만, 둘 다 작성할 때도 있고, 상태가 중요하다면 상태를, 호출 여부가 중요하면 행위 검증을
  - BDDMockito
    - 검증 절에서 verify 대신 then 쓰면 더 가독성이 좋다
  - then.should 체이닝 가독성이 좋다.
  - then하고 should() 함수에 인자를 안주면 1회 호출을 검증
    - 호출을 안했다는 것을 검증하려면 should(never())
    - 만약 여러 번 호출 검증은 should(times(n))
  - 비동기 호출이나 이벤트 검증은 이벤트 관련 테스트도 가능
    - 대부분 호출 여부만 보면 된다
  - 만약 통합으로 보면 DB 접근과 같은 외부 사용시 Mocking 하거나 스텁을 사용하면 된다.
  - ArgumentCaptor를 쓰지말고, anyXX 를 활용하자
  - eq() 를 사용해서 특정 값을 좁혀놓는것도 안정성에 좋다
  - 테스트 코드 작성시 굳이 하지 않아도 될 테스트는 하지 않아도 된다.
    - 예를 들어, RequestParam 에서 Long으로 받기로 되어있는데, 문자열로 들어올 때 스프링이 걸러주는지를 테스트 하는 경우
      - 스프링이 알아서 걸러주기 때문에 굳이 하지 않아도 되는 테스트 케이스이다.
  - given , when , then 에도 명확하게 주석 달기
  - 하나의 케이스에서 여러 검증을 수행하는 경우 @nested를 활용할 수 있다.

- 추후 해볼 것!
  - given // when // then 명확히 주석으로 나누기
  - 서비스 레이어 명확히 주석으로 나누기
  - then should
  - 동시성 고려하기
</details>


<details>
<summary> <b>Step 2. 서버 구조 설계</b> </summary>

- 깨닫게 된 것
  - 문서가 중요
  - 설계는 곧 문서로 나타남

- 배운 것
  - 문서대로 개발 진행
  - 설계가 잘 되어있으면 개발은 스무스함.

**중요**
- 필요한 모든 내용이 들어가 있는가
- 필요한 내용만 들어가 있는가
- 모든 구성 요소를 이해하고 있는가
- 협업을 고려한 문서인가


#### 멘토님이 생각하는 설계 FLOW**

   1. 무조건 있을 수 밖에 없는 기능을 생각한다. -> 예를 들어, e-commerce라면 상품 조회 / 구매 / 포인트 충전 등등 
   2. API 명세
   3. ERD
   4. 인프라 구조도
   5. 서비스에서 특별히 붙여야되는 기능을 정리한다.
      -> 여기에 맞춰서 2, 3, 4 를 지속적으로 업데이트한다.


- 코치님은 개인적으로 DB가 데이터를 정하는 것을 선호하지 않음.(예를 들면 auto increment가 될 수 있음)
  - 애플리케이션 내의 비즈니스로직으로 컨트롤하는 것을 선호함. 
  - 일단 나도 코치님 따라 해보는 것으로 하기
- 모든 선택의 근거가 있어야함(찾는 것 아님)
- ERD가 API 명세는 충족하지만 API 명세가 ERD를 충족하지 못할 수도 있다.
  - 예를 들어 유저의 성별이 M | F 로 enum 처리를 할 수도 있지만 이후 사회적 이슈에 따라 유저를 표기하지 않을 수도 있고 없는 경우도 있다.
  - 따라서 API 명세로는 그렇게 되어있지만 ERD 상으론 열려있는 구조가 되어야 한다
- 문서는 시간이 지나서 계속 바뀔 수 밖에 없다. 
  - 처음부터 완벽할 수 없다.
- 인프라 구조도에서 app의 ip로 접속하기보단 앞에 DNS를 통해서 프론트 개발자가 쉽게 접근할 수 있도록 한다. 
- 개발 언어와 스택, DB 같은 경우에도 선택의 이유가 있어야한다.
  - 우리 팀이 해당 언어 및 프레임워크에 대한 이해가 높다)
- ERD에서 애매모호할 땐 일단은 STRING으로 지정한다.
  - STRING에서 INTEGER로 변환하는 것은 쉽지만 반대의 경우 INTEGER로 했다가 해당 값에 문자열이 들어가면 그렇게 변환하는 것은 쉽지 않다


- 개선할 것
  - API 명세 : 조금 더 디테일하게 (일단은 ai 피드백 필요)
  - 인프라 구조도 : 지금 redis가 필요 없음
  - 도메인 
    - 회원
      - 역할 : 구매자 / 판매자 : 기본 구매자, 회원의 의사에 따라 판매자도 가능

</details>

<details>
<summary> <b>Step 3. 클린 아키텍처로 안정성 확보</b> </summary>
</details>
