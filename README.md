# 항해 Lite 백엔드 코스

# e-커머스 서비스


## Description

- `e-커머스 상품 주문 서비스 시나리오` 입니다.
- 상품 주문에 필요한 메뉴 정보들을 구성하고 조회가 가능해야 합니다.
- 사용자는 상품을 여러개 선택해 주문할 수 있고, 미리 충전한 잔액을 이용합니다.
- 상품 주문 내역을 통해 판매량이 가장 높은 상품을 추천합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 상품 조회 API
    - 주문 / 결제 API
    - 포인트 충전 / 조회 API
    - 선착순 쿠폰 API
    - 인기 판매 상품 조회 API

## API Specs

- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- **(심화)** 재고 관리에 문제 없도록 구현합니다.
- **(심화)** 동시성 이슈를 고려하여 구현합니다.
- **(심화)** 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.

1️⃣**`필수` 상품 조회 API**

- 상품 정보 ( ID, 이름, 가격, 잔여수량 ) 을 조회하는 API 를 작성합니다.
- 조회시점의 상품별 잔여수량이 정확하면 좋습니다.

2️⃣**`필수`** **주문 / 결제 API**

- 사용자 식별자와 (상품 ID, 수량) 목록을 입력받아 주문하고 결제를 수행하는 API 를 작성합니다.
- 결제는 기 충전된 잔액을 기반으로 수행하며 성공할 시 잔액을 차감해야 합니다.
- 데이터 분석을 위해 결제 성공 시에 실시간으로 주문 정보를 데이터 플랫폼에 전송해야 합니다. ( 데이터 플랫폼이 어플리케이션 `외부` 라는 가정만 지켜 작업해 주시면 됩니다 )

> 데이터 플랫폼으로의 전송 기능은 Mock API, Fake Module 등 다양한 방법으로 접근해 봅니다.
>

3️⃣**`필수`** **포인트 충전 / 조회 API**

- 결제에 사용될 포인트를 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 포인트를 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔여 포인트를 조회합니다.

4️⃣ **`선택` 선착순 쿠폰 기능**

- 선착순 쿠폰 발급 API 및 보유 쿠폰 목록 조회 API 를 작성합니다.
- 주문 시에 유효한 할인 쿠폰을 함께 제출하면, 전체 주문금액에 대해 할인 혜택을 부여받을 수 있습니다.
    - 사용자는 선착순으로 할인 쿠폰을 발급받을 수 있습니다.

5️⃣ **`선택` 인기 상품 조회 API** (STEP7 과제에 활용)

- 최근 3일간 가장 많이 팔린 상위 5개 상품 정보를 제공하는 API 를 작성합니다.
- 통계 정보를 다루기 위한 기술적 고민을 충분히 해보도록 합니다.

---

<aside>
💡 <b>KEY POINT</b>

</aside>

- 동시에 여러 주문이 들어올 경우, 유저의 보유 잔고에 대한 처리가 정확해야 합니다.
- 각 상품의 재고 관리가 정상적으로 이루어져 잘못된 주문이 발생하지 않도록 해야 합니다.


### 필수 과제 - 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
  - `e-commerce` : 상품 조회, 주문/결제 기능, 포인트 충전 기능
  - 단, 비지니스 로직에서 다음을 따라야 합니다.
    - 한개의 비지니스 로직을 클린아키텍처로 구현하고 다른 비지니스 로직은 레이어드로 구현할것
      - “e-커머스 시나리오에서 '주문/결제 기능'을 클린 아키텍처로 구현”
        - 도메인 로직이 복잡
        - 여러 모듈(예: 결제 게이트웨이, 재고 관리, 사용자 관리 등)과 상호작용해야 해서 클린 아키텍처의 장점을 살리기 좋기 때문
      - 여러 기능 Mock을 적극 활용해주세요
        - 예를들어
          - `주문/결제 기능` 테스트 시에는 `ProductRepository`, `UserRepository`, `PaymentGateway`, `EventPublisher` 등은 모두 Mock으로 대체하고, OrderUseCase 자체의 도메인 로직만 검증하도록 작성해야 합니다.
          - 이는 외부 시스템에 의존하지 않고도 순수한 비즈니스 로직 테스트가 가능하게 하기 위함입니다.

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함

### (선택)심화 과제 - 심화 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
  - `e-commerce` : 선착순 쿠폰 관련 기능

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함.
> 심화 과제까지 마무리한 후에는, 로그인 기능등 남은 요구사항들도 차례로 확장해보는 것을 추천.

--------------------------------------

### 각 챕터마다 배운 것

<details>
<summary> <b> Step 1. TDD 기본다지기</b> </summary>

### 기술적 성장

- 새로 학습한 개념
  - 행위 검증에서 then.should 절이 쓰인다는 것 
  - 호출 여부가 중요할 때 사용한다는 것 
  - Mocking을 했을 때 메서드 내부에서 호출하는 메서드를 Stub 해줘야하는 것 
  - given절에서는 matcher(eq, anyXX)를 사용하지만, willReturn에서는 matcher가 아닌 실제 값을 넣어줘야하는 것 
- 기존 지식의 재발견/심화 
- @ExtendWith(MockitoExtension.class) 와 @WebMvcTest 차이 그리고 @mock과 @MockBean의 차이 를 알 수 있었고,
  - @WebMvcTest 와 @MockBean을 사용하는 것보다 @ExtendWith(MockitoExtension.class) 와 @mock을 사용하는 것이 더욱 빠르다는 것.
- 행위 검증/상태 검증이 있는 것 -> 기존에 자주 쓰던 assert는 상태 검증을 하는 것

- 규칙 정리 
  - 하나에 한 책임 
  - 외부 의존성 처리 
  - 테스트는 재현 가능해야함(랜덤/시간 의존 제거 -> 고정된 수치)
  - 명확한 테스트 이름 
  - `Assertions`은 명확하게 
    - 보다 크다 X
    - "="
  
- 안티패턴
  - 테스트 간 상태 공유 X
  - sleep 사용 X
    - 비동기 처리 대기 시 Awaitillity 라이브러리 등 사용 X
  - 의미 없는 이름X
  - 과도한 Mock 검증
    - 내부 구현을 너무 상세히 검증하기 보단 외부로 보이는 결과에 집중하도록

- 알게된 내용들
  - 상태검증(Assert)/행위검증(then/should)
    - GPT가 둘 다 해야된다고 알려주긴했지만, 둘 다 작성할 때도 있고, 상태가 중요하다면 상태를, 호출 여부가 중요하면 행위 검증을
  - BDDMockito
    - 검증 절에서 verify 대신 then 쓰면 더 가독성이 좋다
  - then.should 체이닝 가독성이 좋다.
  - then하고 should() 함수에 인자를 안주면 1회 호출을 검증
    - 호출을 안했다는 것을 검증하려면 should(never())
    - 만약 여러 번 호출 검증은 should(times(n))
  - 비동기 호출이나 이벤트 검증은 이벤트 관련 테스트도 가능
    - 대부분 호출 여부만 보면 된다
  - 만약 통합으로 보면 DB 접근과 같은 외부 사용시 Mocking 하거나 스텁을 사용하면 된다.
  - ArgumentCaptor를 쓰지말고, anyXX 를 활용하자
  - eq() 를 사용해서 특정 값을 좁혀놓는것도 안정성에 좋다
  - 테스트 코드 작성시 굳이 하지 않아도 될 테스트는 하지 않아도 된다.
    - 예를 들어, RequestParam 에서 Long으로 받기로 되어있는데, 문자열로 들어올 때 스프링이 걸러주는지를 테스트 하는 경우
      - 스프링이 알아서 걸러주기 때문에 굳이 하지 않아도 되는 테스트 케이스이다.
  - given , when , then 에도 명확하게 주석 달기
  - 하나의 케이스에서 여러 검증을 수행하는 경우 @nested를 활용할 수 있다.

- 추후 해볼 것!
  - given // when // then 명확히 주석으로 나누기
  - 서비스 레이어 명확히 주석으로 나누기
  - then should
  - 동시성 고려하기
</details>


<details>
<summary> <b>Step 2. 서버 구조 설계</b> </summary>

- 깨닫게 된 것
  - 문서가 중요
  - 설계는 곧 문서로 나타남

- 배운 것
  - 문서대로 개발 진행
  - 설계가 잘 되어있으면 개발은 스무스함.

**중요**
- 필요한 모든 내용이 들어가 있는가
- 필요한 내용만 들어가 있는가
- 모든 구성 요소를 이해하고 있는가
- 협업을 고려한 문서인가


#### 멘토님이 생각하는 설계 FLOW**

   1. 무조건 있을 수 밖에 없는 기능을 생각한다. -> 예를 들어, e-commerce라면 상품 조회 / 구매 / 포인트 충전 등등 
   2. API 명세
   3. ERD
   4. 인프라 구조도
   5. 서비스에서 특별히 붙여야되는 기능을 정리한다.
      -> 여기에 맞춰서 2, 3, 4 를 지속적으로 업데이트한다.


- 코치님은 개인적으로 DB가 데이터를 정하는 것을 선호하지 않음.(예를 들면 auto increment가 될 수 있음)
  - 애플리케이션 내의 비즈니스로직으로 컨트롤하는 것을 선호함. 
  - 일단 나도 코치님 따라 해보는 것으로 하기
- 모든 선택의 근거가 있어야함(찾는 것 아님)
- ERD가 API 명세는 충족하지만 API 명세가 ERD를 충족하지 못할 수도 있다.
  - 예를 들어 유저의 성별이 M | F 로 enum 처리를 할 수도 있지만 이후 사회적 이슈에 따라 유저를 표기하지 않을 수도 있고 없는 경우도 있다.
  - 따라서 API 명세로는 그렇게 되어있지만 ERD 상으론 열려있는 구조가 되어야 한다
- 문서는 시간이 지나서 계속 바뀔 수 밖에 없다. 
  - 처음부터 완벽할 수 없다.
- 인프라 구조도에서 app의 ip로 접속하기보단 앞에 DNS를 통해서 프론트 개발자가 쉽게 접근할 수 있도록 한다. 
- 개발 언어와 스택, DB 같은 경우에도 선택의 이유가 있어야한다.
  - 우리 팀이 해당 언어 및 프레임워크에 대한 이해가 높다)
- ERD에서 애매모호할 땐 일단은 STRING으로 지정한다.
  - STRING에서 INTEGER로 변환하는 것은 쉽지만 반대의 경우 INTEGER로 했다가 해당 값에 문자열이 들어가면 그렇게 변환하는 것은 쉽지 않다


- 개선할 것
  - API 명세 : 조금 더 디테일하게 (일단은 ai 피드백 필요)
  - 인프라 구조도 : 지금 redis가 필요 없음
  - 도메인 
    - 회원
      - 역할 : 구매자 / 판매자 : 기본 구매자, 회원의 의사에 따라 판매자도 가능

</details>

<details>
<summary> <b>Step 3. 클린 아키텍처로 안정성 확보</b> </summary>
</details>
