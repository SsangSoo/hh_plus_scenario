# 인프라 구조도 - e-commerce 서비스

## 인프라 아키텍처 개요

<div><img src="image/인프라구조도.png"></div>




### 주요 컴포넌트

|컴포넌트| 기술 스택               |역할|
|-|---------------------|-|
|WAS| Spring Boot(Docker) | 비즈니스 로직 처리|
|Database| MySQL | 애플리케이션 데이터 영구 저장|
|Cache| Redis | 결제 중복 방지 (Idempotency Key 관리)|



### 요청 처리 흐름

1. 사용자 요청
2. WAS로 접근
3. 비즈니스 로직 처리(RDB 및 Redis 조회)
4. 응답 반환




### 배포 전략
- 미선정



**모든 ADR(Architecture Decision Record : 아키텍처에 대한 의사결정 문서) 작성자는 `김성수` 본인입니다.**



### ADR-001 : e-commerce 애플리케이션 개발 언어 및 프레임워크 선택

#### 상태
✅ 수락됨

#### 날짜
- 2025-11-01

#### 문제점
e-commerce 애플리케이션 개발에 필요한 언어와 프레임워크 선택 필요

#### 결정
- java/spring 선택

#### 근거
- 개발자(나)의 언어와 프레임워크에 대한 이해도가 java와 spring 에 대한 이해도가 보다 높기 때문에 해당 언어와 프레임워크를 선택.
- 안정적인 생태계와 커뮤니티 지원
- 대규모 애플리케이션 확장성 우수



### ADR-002 : MySQL 도입

#### 상태
✅ 수락됨

#### 날짜
- 2025-11-01

#### 문제점
애플리케이션의 데이터를 저장할 RDB 선택 필요 

#### 결정
- MySQL 선택

#### 근거
- 안정적인 생태계와 커뮤니티 지원
- 개발자(나)가 RDB 중 MySQL에 가장 친숙함.

#### 대안
- MariaDB 
- Oracle
- PostgreSQL



### ADR-003 : Docker 도입

#### 상태
✅ 수락됨

#### 날짜
- 2025-11-01

#### 문제점
로컬 개발 환경과 프로덕션 환경의 불일치로 인한 배포 복잡도 증가

#### 근거
- 개발/프로덕션 환경 통일
- 빌드와 배포 자동화 가능
- 향후 Kubernetes 확장성 고려

#### 대안
- 도커를 사용하지 않고, 온프레미스에서 직접 서버를 띄울 수도 있다.
- 하지만, 추후 클라우드로 도입 혹은 Kubernetes의 확장성을 고려하여, 도커를 적극적으로 도입함.



### ADR-004 : Redis 도입

#### 상태
✅ 수락됨

#### 날짜
- 2026-01-03

#### 문제점
- 결제 중복 요청을 방지하기 위해 header에 `idempotency_key` 를 넣음.
- 해당 키를 통해 요청된 결제가 중복 결제인지를 체크하는 과정이 필요했음

#### 근거
- 많이 사용되기도 하고, 또한 메모리 DB로써 빠른 속도를 내기 때문에, 사용하기로 결정

#### 대안
- DB를 통해 확인할 수도 있지만, DBC을 낭비하게 됨.


### ADR-005 : Redis 클라이언트로 StringRedisTemplate 선택

#### 상태
✅ 수락됨

#### 날짜
- 2026-01-23

#### 문제점
- 쿠폰 선착순에 대한 처리 시간이 너무 길음.
- 성능에 이점을 얻을 필요가 있음.
- 현재 분산락과 DB의 트랜잭션을 같이 사용하고 있어서 성능의 이점을 얻고자 Redis를 사용하기로 채택함. 

#### 근거
- Redis는 메모리 기반, DB는 디스크 기반이기 때문에 당연히 메모리의 호출비용이 더 적음.
- 그 중에서도 Redis를 사용하는 Template 중 StringRedisTemplate이 더 가볍고, 네트워크 전송량도 더 적어 해당 기술 채택하기로 함.

#### 대안
- RedisTemplate 사용가능.



### ADR-006 : Apache Kafka 도입

#### 상태
✅ 수락됨

#### 날짜
- 2026-02-22

#### 문제점
- 현재 Spring `ApplicationEventPublisher`를 사용한 이벤트 기반 아키텍처는 **단일 JVM 내에서만 이벤트 전파** 가능
- 다중 인스턴스 환경에서 이벤트 공유 불가
- 애플리케이션 재시작 시 처리 중인 이벤트 유실 가능성
- MSA 전환 시 서비스 간 이벤트 전파 메커니즘 재구현 필요
- 대용량 트래픽(선착순 쿠폰 발급 등) 처리 시 확장성 한계

#### 결정
- Apache Kafka 도입
- 결제 완료(`payment-completed`), 쿠폰 발행(`coupon-issued`), Outbox 정리(`outbox-cleanup`) 이벤트를 Kafka 토픽으로 전환

#### 근거
- **메시지 영속성**: 디스크에 메시지를 저장하여 데이터 유실 방지
- **높은 처리량**: 배치 처리, 압축, 제로 카피로 초당 수백만 건 처리 가능
- **분산 처리**: 파티션 기반 병렬 처리로 부하 분산
- **재처리 가능**: offset 기반으로 장애 복구 시 마지막 처리 지점부터 재개
- **느슨한 결합**: Producer와 Consumer 간 독립성 보장으로 MSA 전환 기반 마련
- **Consumer Group**: 다중 인스턴스 환경에서 자동 분산 처리

#### 대안
- **RabbitMQ**: AMQP 프로토콜 기반, 복잡한 라우팅에 유리하나 대용량 처리에서 Kafka보다 처리량 낮음
- **AWS SQS**: 관리형 서비스로 운영 부담 적으나, 메시지 순서 보장 제한적
- **Redis Pub/Sub**: 메시지 영속성 없음, 구독자 없으면 메시지 유실



---

### ADR-00N : ADR 템플릿

#### 상태
제안됨 / 승인됨 / 구현중 / 완료

#### 날짜

#### 문제점

#### 결정

#### 근거

#### 대안