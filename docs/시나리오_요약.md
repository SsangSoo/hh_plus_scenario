# 과제 요약

## ch.02

## Description

- `e-커머스 상품 주문 서비스 시나리오` 입니다.
- 상품 주문에 필요한 메뉴 정보들을 구성하고 조회가 가능해야 합니다.
- 사용자는 상품을 여러개 선택해 주문할 수 있고, 미리 충전한 잔액을 이용합니다.
- 상품 주문 내역을 통해 판매량이 가장 높은 상품을 추천합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 상품 조회 API
    - 주문 / 결제 API
    - 포인트 충전 / 조회 API
    - 선착순 쿠폰 API
    - 인기 판매 상품 조회 API

## API Specs

- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- **(심화)** 재고 관리에 문제 없도록 구현합니다.
- **(심화)** 동시성 이슈를 고려하여 구현합니다.
- **(심화)** 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.

1️⃣**`필수` 상품 조회 API**

- 상품 정보 ( ID, 이름, 가격, 잔여수량 ) 을 조회하는 API 를 작성합니다.
- 조회시점의 상품별 잔여수량이 정확하면 좋습니다.

2️⃣**`필수`** **주문 / 결제 API**

- 사용자 식별자와 (상품 ID, 수량) 목록을 입력받아 주문하고 결제를 수행하는 API 를 작성합니다.
- 결제는 기 충전된 잔액을 기반으로 수행하며 성공할 시 잔액을 차감해야 합니다.
- 데이터 분석을 위해 결제 성공 시에 실시간으로 주문 정보를 데이터 플랫폼에 전송해야 합니다. ( 데이터 플랫폼이 어플리케이션 `외부` 라는 가정만 지켜 작업해 주시면 됩니다 )

> 데이터 플랫폼으로의 전송 기능은 Mock API, Fake Module 등 다양한 방법으로 접근해 봅니다.
>

3️⃣**`필수`** **포인트 충전 / 조회 API**

- 결제에 사용될 포인트를 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 포인트를 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔여 포인트를 조회합니다.

4️⃣ **`선택` 선착순 쿠폰 기능**

- 선착순 쿠폰 발급 API 및 보유 쿠폰 목록 조회 API 를 작성합니다.
- 주문 시에 유효한 할인 쿠폰을 함께 제출하면, 전체 주문금액에 대해 할인 혜택을 부여받을 수 있습니다.
    - 사용자는 선착순으로 할인 쿠폰을 발급받을 수 있습니다.

5️⃣ **`선택` 인기 상품 조회 API** (STEP7 과제에 활용)

- 최근 3일간 가장 많이 팔린 상위 5개 상품 정보를 제공하는 API 를 작성합니다.
- 통계 정보를 다루기 위한 기술적 고민을 충분히 해보도록 합니다.

---

<aside>
💡 <b>KEY POINT</b>

</aside>

- 동시에 여러 주문이 들어올 경우, 유저의 보유 잔고에 대한 처리가 정확해야 합니다.
- 각 상품의 재고 관리가 정상적으로 이루어져 잘못된 주문이 발생하지 않도록 해야 합니다.


## ch.03

### 필수 과제 - 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
    - `e-commerce` : 상품 조회, 주문/결제 기능, 포인트 충전 기능
    - 단, 비지니스 로직에서 다음을 따라야 합니다.
        - 한개의 비지니스 로직을 클린아키텍처로 구현하고 다른 비지니스 로직은 레이어드로 구현할것
            - “e-커머스 시나리오에서 '주문/결제 기능'을 클린 아키텍처로 구현”
                - 도메인 로직이 복잡
                - 여러 모듈(예: 결제 게이트웨이, 재고 관리, 사용자 관리 등)과 상호작용해야 해서 클린 아키텍처의 장점을 살리기 좋기 때문
            - 여러 기능 Mock을 적극 활용해주세요
                - 예를들어
                    - `주문/결제 기능` 테스트 시에는 `ProductRepository`, `UserRepository`, `PaymentGateway`, `EventPublisher` 등은 모두 Mock으로 대체하고, OrderUseCase 자체의 도메인 로직만 검증하도록 작성해야 합니다.
                    - 이는 외부 시스템에 의존하지 않고도 순수한 비즈니스 로직 테스트가 가능하게 하기 위함입니다.

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함

### (선택)심화 과제 - 심화 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
    - `e-commerce` : 선착순 쿠폰 관련 기능

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함.
> 심화 과제까지 마무리한 후에는, 로그인 기능등 남은 요구사항들도 차례로 확장해보는 것을 추천.


## ch.04

- Infrastructure Layer 작성 (“외부 세계와 연결된 모든 것”을 담당하는 계층)
- 기능별 통합 테스트 작성
- Testcontainers(Optional) 또는 테스트 전용 DB로 테스트 가능하도록 구성

- 1. Infrastructure Layer 구현
  - UserBalanceRepository, ProductRepository, OrderRepository, CouponRepository 등 도메인 기반 리포지토리 구현
  - 외부 메시지 전송 기능은 Kafka 대신 MockMessageProducer 또는 Outbox 테이블 방식으로 구현
  - 외부 API/Fake Producer 등은 의존성 주입 형태로 설계하여 테스트 가능하도록 구성 
    - 예: 주문이 완료되었을 때 
      - -> 데이터 플랫폼(외부 시스템)에 주문 정보를 실시간 전송해야 한다
- 2. 기능별 통합 테스트 작성
  - 충전 API → 주문 API까지 잔액 변경 테스트 포함 
  - 상품 주문 & 결제 흐름 전체 통합 테스트 
    - 주문 → 재고 차감 → 잔액 차감 → 주문 저장 → 외부 전송 Mock 검증 
  - 외부 메시지 전송 실패 시 fallback 처리 검증 (e.g. Outbox 저장 여부 확인)
  - 결제 API는 idempotency_key 사용 → 중복 요청 테스트 포함 
  - 쿠폰 발급 경쟁 조건 테스트: 동시에 요청 시 한 명만 성공
    

- (선택)심화 과제 - DB -> 인기 있는 상품 조회를 구현했을 떄 필요!!
  - 조회가 오래 걸릴 수 있는 기능을 리스트업하고 분석하여, 테이블 재설계 / 인덱스 등 솔루션을 도출하는 내용의 보고서 작성
  - 주요 기능별 동시성 테스트 작성

> 이번 과제에서 동시성 테스트는 성공하는 것이 목적이 아니라, 어떤 기능에 대해 동시성 이슈가 예민할지를 미리 리스트업하고 작성하여 Rule 로 가두는 것을 목적으로 합니다.


## ch.05 

- 진행중인 시나리오내에서 발생할 수 있는 동시성 이슈를 식별
  - 예상 동시성 이슈
    - 다수 사용자가 동시에 같은 상품을 주문 → 재고 oversell 
    - 동일 유저가 두 번 결제 요청 → 잔액 음수 오류
    - 선착순 쿠폰 발급 요청 몰림 → 쿠폰 초과 발급 / 중복 발급
  - 구현 및 보고서 요구사항
    - 다음 항목 중 2개 이상 구현 및 테스트
      - 재고 감소 동시성 제어 동시성 제어
      - 쿠폰 발급 동시성 제어
      - 잔액 차감 
    - 조건부 UPDATE / SELECT FOR UPDATE / 낙관적 락 중 하나 이상 사용
    - 멀티스레드 테스트 작성 
    - md에 문제 상황, 해결 전략, 테스트 결과를 정리

### 2. Finalize

- 지금까지 구현한 API를 기반으로 서비스 전체가 실제 운영 환경에서도 안정적으로 동작할 수 있도록 마무리 작업을 수행합니다.
- 모든 기능이 정상 동작하고, 예외 상황에 유연하게 대응할 수 있어야 하며, 테스트를 통해 안정성을 검증해야 합니다. 
- 각 기능에 대해 테스트 케이스 1개 이상 작성 필수




## ch.06

### [필수] Distributed Lock(분산락)

- 과제 내용
  - Redis 기반의 분산락을 직접 구현해보고 동작에 대한 통합테스트 작성
  - 주문/예약/결제 기능 등에 (1) 적절한 키 (2) 적절한 범위를 선정해 분산락을 적용
- 주요 평가 기준
  - 분산락에 대한 이해와 DB Tx 과 혼용할 때 주의할 점을 이해하였는지
  - 적절하게 분산락이 적용되는 범위에 대해 구현을 진행하였는지

### [선택] Cache

- 과제 내용
  - 조회가 오래 걸리거나, 자주 변하지 않는 데이터 등 애플리케이션의 요청 처리 성능을 높이기 위해 캐시 전략을 취할 수 있는 구간을 점검하고, 적절한 캐시 전략을 선정
  - 위 구간에 대해 Redis 기반의 캐싱 전략을 시나리오에 적용하고 성능 개선 등을 포함한 보고서 작성 및 제출
- 주요 평가 기준
  - 각 시나리오에서 발생하는 Query 에 대한 충분한 이해가 있는지
  - 각 시나리오에서 캐시 가능한 구간을 분석하였는지
  - 대량의 트래픽 발생시 지연이 발생할 수 있는 조회쿼리에 대해 분석하고, 이에 대한 결과를 작성하였는지


## ch.07 

> 각 시스템(랭킹, 비동기) 디자인 설계 및 개발 후 회고 내용을 담은 보고서 제출

### [필수] Ranking Design  

- 과제 내용
  - 가장 많이 주문한 상품 랭킹을 Redis 기반으로 개발하고 설계 및 구현


### [선택] Asynchronous Design

- 선착순 쿠폰발급 기능에 대해 Redis 기반의 설계를 진행하고, 적절하게 동작할 수 있도록 쿠폰 발급 로직을 개선해 제출


## ch.08

### [필수] Application Event

- 실시간 주문정보(이커머스)를 데이터 플랫폼에 전송(mock API 호출)하는 요구사항을 이벤트를 활용하여 트랜잭션과 관심사를 분리하여 서비스를 개선A

### [선택] Transaction Diagnosis

- 우리 서비스의 규모가 확장되어 MSA의 형태로 각 도메인별로 배포 단위를 분리해야한다면 각각 어떤 도메인으로 배포 단위를 설계할 것인지 결정하고, 그 분리에 따른 트랜잭션 처리의 한계와 해결방안에 대한 서비스 설계 문서 작성하여 제출합니다.

**Try if you want**
- 보상트랜잭션, Saga 패턴 등 활용하여 프로젝트를 고도화
  - Facade 활용한다면 트랜잭션을 도메인 단위로 분리하고 발생하는 분산 트랜잭션을 올바르게 구현하기
  - Facade 없이 서비스간 의존하는 구조라면 어플리케이션 이벤트를 활용하여 각 서비스 의존을 없애기

## ch.09

#### [필수] 카프카 기초 학습 및 활용

- 카프카에 대한 기초 개념을 학습하고 문서로 작성 
  - 기능을 구현해야하는데, 기능을 구현하기 위해서 카프카를 도입하면 되게 효율적임.
  - 그러나 우리 팀에는 카프카에 대해 이해하고 있는 사람들이 아무도 없기 때문에, 카프카가 어떤 것이고, 어떤 이점을 가져는지에 정리해서 공유하는 느낌으로 문서 작성
  - 문서의 내용은 자유로이, 단 방향은 다음과 같이 작성
    - 이벤트의 아이디어를 전체 시스템으로 확장시켜 적용할 수 있다는 내용이 들어가야함.
    - 카프카의 장단점
    - 카프카의 구성 요소 및 대표적인 기능
- 로컬에서 카프카를 설치하고 기본적인 기능을 실습
  - docker compose 통해서 구현 vs 직접 Kafka 구성 vs AWS MSK 
- 진행하고 있는 시나리오에 맞추어 프로젝트에 카프카 적용
  - 기존의 이벤트로 되어있는 부분을 Kafka로 확장

#### [선택]

- 대용량 요청이 발생할 수 있는 지점을 고민 -> 카프카를 활용하면 좋을 포인트
- 개선할 내용에 대한 설계 문서를 작성
- 설계한 내용을 바탕으로 실제 카프카를 활용하여 대응하도록 변경


