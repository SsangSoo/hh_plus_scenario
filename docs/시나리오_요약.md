# 과제 요약

## ch.02

## Description

- `e-커머스 상품 주문 서비스 시나리오` 입니다.
- 상품 주문에 필요한 메뉴 정보들을 구성하고 조회가 가능해야 합니다.
- 사용자는 상품을 여러개 선택해 주문할 수 있고, 미리 충전한 잔액을 이용합니다.
- 상품 주문 내역을 통해 판매량이 가장 높은 상품을 추천합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 상품 조회 API
    - 주문 / 결제 API
    - 포인트 충전 / 조회 API
    - 선착순 쿠폰 API
    - 인기 판매 상품 조회 API

## API Specs

- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- **(심화)** 재고 관리에 문제 없도록 구현합니다.
- **(심화)** 동시성 이슈를 고려하여 구현합니다.
- **(심화)** 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.

1️⃣**`필수` 상품 조회 API**

- 상품 정보 ( ID, 이름, 가격, 잔여수량 ) 을 조회하는 API 를 작성합니다.
- 조회시점의 상품별 잔여수량이 정확하면 좋습니다.

2️⃣**`필수`** **주문 / 결제 API**

- 사용자 식별자와 (상품 ID, 수량) 목록을 입력받아 주문하고 결제를 수행하는 API 를 작성합니다.
- 결제는 기 충전된 잔액을 기반으로 수행하며 성공할 시 잔액을 차감해야 합니다.
- 데이터 분석을 위해 결제 성공 시에 실시간으로 주문 정보를 데이터 플랫폼에 전송해야 합니다. ( 데이터 플랫폼이 어플리케이션 `외부` 라는 가정만 지켜 작업해 주시면 됩니다 )

> 데이터 플랫폼으로의 전송 기능은 Mock API, Fake Module 등 다양한 방법으로 접근해 봅니다.
>

3️⃣**`필수`** **포인트 충전 / 조회 API**

- 결제에 사용될 포인트를 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 포인트를 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔여 포인트를 조회합니다.

4️⃣ **`선택` 선착순 쿠폰 기능**

- 선착순 쿠폰 발급 API 및 보유 쿠폰 목록 조회 API 를 작성합니다.
- 주문 시에 유효한 할인 쿠폰을 함께 제출하면, 전체 주문금액에 대해 할인 혜택을 부여받을 수 있습니다.
    - 사용자는 선착순으로 할인 쿠폰을 발급받을 수 있습니다.

5️⃣ **`선택` 인기 상품 조회 API** (STEP7 과제에 활용)

- 최근 3일간 가장 많이 팔린 상위 5개 상품 정보를 제공하는 API 를 작성합니다.
- 통계 정보를 다루기 위한 기술적 고민을 충분히 해보도록 합니다.

---

<aside>
💡 <b>KEY POINT</b>

</aside>

- 동시에 여러 주문이 들어올 경우, 유저의 보유 잔고에 대한 처리가 정확해야 합니다.
- 각 상품의 재고 관리가 정상적으로 이루어져 잘못된 주문이 발생하지 않도록 해야 합니다.


## ch.03

### 필수 과제 - 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
    - `e-commerce` : 상품 조회, 주문/결제 기능, 포인트 충전 기능
    - 단, 비지니스 로직에서 다음을 따라야 합니다.
        - 한개의 비지니스 로직을 클린아키텍처로 구현하고 다른 비지니스 로직은 레이어드로 구현할것
            - “e-커머스 시나리오에서 '주문/결제 기능'을 클린 아키텍처로 구현”
                - 도메인 로직이 복잡
                - 여러 모듈(예: 결제 게이트웨이, 재고 관리, 사용자 관리 등)과 상호작용해야 해서 클린 아키텍처의 장점을 살리기 좋기 때문
            - 여러 기능 Mock을 적극 활용해주세요
                - 예를들어
                    - `주문/결제 기능` 테스트 시에는 `ProductRepository`, `UserRepository`, `PaymentGateway`, `EventPublisher` 등은 모두 Mock으로 대체하고, OrderUseCase 자체의 도메인 로직만 검증하도록 작성해야 합니다.
                    - 이는 외부 시스템에 의존하지 않고도 순수한 비즈니스 로직 테스트가 가능하게 하기 위함입니다.

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함

### (선택)심화 과제 - 심화 로직 구현 및 테스트코드 작성
- 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성
    - `e-commerce` : 선착순 쿠폰 관련 기능

> 단위 테스트 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함.
> 심화 과제까지 마무리한 후에는, 로그인 기능등 남은 요구사항들도 차례로 확장해보는 것을 추천.


## ch.04

- Infrastructure Layer 작성 (“외부 세계와 연결된 모든 것”을 담당하는 계층)
- 기능별 통합 테스트 작성
- Testcontainers(Optional) 또는 테스트 전용 DB로 테스트 가능하도록 구성

- 1. Infrastructure Layer 구현
  - UserBalanceRepository, ProductRepository, OrderRepository, CouponRepository 등 도메인 기반 리포지토리 구현
  - 외부 메시지 전송 기능은 Kafka 대신 MockMessageProducer 또는 Outbox 테이블 방식으로 구현
  - 외부 API/Fake Producer 등은 의존성 주입 형태로 설계하여 테스트 가능하도록 구성 
    - 예: 주문이 완료되었을 때 
      - -> 데이터 플랫폼(외부 시스템)에 주문 정보를 실시간 전송해야 한다
- 2. 기능별 통합 테스트 작성
  - 충전 API → 주문 API까지 잔액 변경 테스트 포함 
  - 상품 주문 & 결제 흐름 전체 통합 테스트 
    - 주문 → 재고 차감 → 잔액 차감 → 주문 저장 → 외부 전송 Mock 검증 
  - 외부 메시지 전송 실패 시 fallback 처리 검증 (e.g. Outbox 저장 여부 확인)
  - 결제 API는 idempotency_key 사용 → 중복 요청 테스트 포함 
  - 쿠폰 발급 경쟁 조건 테스트: 동시에 요청 시 한 명만 성공
    

- (선택)심화 과제 - DB -> 인기 있는 상품 조회를 구현했을 떄 필요!!
  - 조회가 오래 걸릴 수 있는 기능을 리스트업하고 분석하여, 테이블 재설계 / 인덱스 등 솔루션을 도출하는 내용의 보고서 작성
  - 주요 기능별 동시성 테스트 작성

> 이번 과제에서 동시성 테스트는 성공하는 것이 목적이 아니라, 어떤 기능에 대해 동시성 이슈가 예민할지를 미리 리스트업하고 작성하여 Rule 로 가두는 것을 목적으로 합니다.


## ch.05 

- 진행중인 시나리오내에서 발생할 수 있는 동시성 이슈를 식별
  - 예상 동시성 이슈
    - 다수 사용자가 동시에 같은 상품을 주문 → 재고 oversell 
    - 동일 유저가 두 번 결제 요청 → 잔액 음수 오류
    - 선착순 쿠폰 발급 요청 몰림 → 쿠폰 초과 발급 / 중복 발급
  - 구현 및 보고서 요구사항
    - 다음 항목 중 2개 이상 구현 및 테스트
      - 재고 감소 동시성 제어 동시성 제어
      - 쿠폰 발급 동시성 제어
      - 잔액 차감 
    - 조건부 UPDATE / SELECT FOR UPDATE / 낙관적 락 중 하나 이상 사용
    - 멀티스레드 테스트 작성 
    - md에 문제 상황, 해결 전략, 테스트 결과를 정리

### 2. Finalize

- 지금까지 구현한 API를 기반으로 서비스 전체가 실제 운영 환경에서도 안정적으로 동작할 수 있도록 마무리 작업을 수행합니다.
- 모든 기능이 정상 동작하고, 예외 상황에 유연하게 대응할 수 있어야 하며, 테스트를 통해 안정성을 검증해야 합니다. 
- 각 기능에 대해 테스트 케이스 1개 이상 작성 필수










